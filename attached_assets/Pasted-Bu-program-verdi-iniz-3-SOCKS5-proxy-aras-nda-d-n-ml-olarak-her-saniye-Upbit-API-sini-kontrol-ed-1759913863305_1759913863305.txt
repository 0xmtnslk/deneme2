Bu program, verdiÄŸiniz 3 SOCKS5 proxy arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼mlÃ¼ olarak her saniye Upbit API'sini kontrol edecek, ETag ile deÄŸiÅŸiklikleri takip edecek ve yeni bir kripto para listelemesi duyurusu bulduÄŸunda bunu tespit edecektir.

ProgramÄ±n Ã–zellikleri
Proxy Rotasyonu: VerdiÄŸiniz 3 SOCKS5 proxy'sini her istekte sÄ±rayla kullanÄ±r. Bu sayede her bir proxy 3 saniyede bir kullanÄ±lmÄ±ÅŸ olur ve saatlik istek limiti (proxy baÅŸÄ±na 1200) aÅŸÄ±lmaz. (1 istek/3sn * 3600sn/saat = 1200 istek/saat)

ETag KontrolÃ¼: Upbit sunucusuna gereksiz yÃ¼k bindirmemek ve veriyi verimli bir ÅŸekilde kontrol etmek iÃ§in If-None-Match baÅŸlÄ±ÄŸÄ±nÄ± (ETag) kullanÄ±r.

Dinamik Listeleme Tespiti: Sadece yeni eklenen duyurulardaki coin ticker'larÄ±nÄ± tespit eder ve ekrana yazdÄ±rÄ±r.

Hata YÃ¶netimi: Proxy baÄŸlantÄ± hatalarÄ± veya API'den gelebilecek hatalara karÅŸÄ± temel dÃ¼zeyde koruma iÃ§erir.

Go (Golang) Kodu
AÅŸaÄŸÄ±daki kodu main.go adÄ±nda bir dosyaya kaydedin.

Go

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"regexp"
	"sync"
	"time"

	"golang.org/x/net/proxy"
)

// Upbit API'sinden gelen JSON yanÄ±tÄ±nÄ± modellemek iÃ§in struct'lar
type APIResponse struct {
	Success bool `json:"success"`
	Data    Data `json:"data"`
}

type Data struct {
	List []Announcement `json:"list"`
}

type Announcement struct {
	ID    int    `json:"id"`
	Title string `json:"title"`
}

// Global deÄŸiÅŸkenler
var (
	// Sorgulanacak API URL'si
	apiURL = "https://api-manager.upbit.com/api/v1/announcements?os=web&page=1&per_page=20&category=all"

	// Proxy listesi
	proxies = []string{
		"socks5://doproxy1:DigitalOcean55@143.198.221.194:1080",
		"socks5://doproxy2:DigitalOcean55@159.223.68.49:1080",
		"socks5://doproxy3:DigitalOcean55@104.248.147.230:1080",
	}

	// Ticker'larÄ± ayÄ±klamak iÃ§in regular expression
	// Parantez iÃ§indeki bÃ¼yÃ¼k harfli metni yakalar: (XYZ)
	tickerRegex = regexp.MustCompile(`\(([A-Z0-9]+)\)`)

	// Ã–nbellek ve durum yÃ¶netimi iÃ§in
	cachedTickers = make(map[string]bool) // Set gibi kullanmak iÃ§in map
	cachedETag    = ""
	proxyIndex    = 0
	mu            sync.Mutex // EÅŸzamanlÄ± eriÅŸimi Ã¶nlemek iÃ§in Mutex
)

// Belirtilen SOCKS5 proxy'si ile bir http.Client oluÅŸturan fonksiyon
func createProxyClient(proxyURL string) (*http.Client, error) {
	parsedURL, err := url.Parse(proxyURL)
	if err != nil {
		return nil, fmt.Errorf("proxy URL'si ayrÄ±ÅŸtÄ±rÄ±lamadÄ±: %w", err)
	}

	dialer, err := proxy.FromURL(parsedURL, proxy.Direct)
	if err != nil {
		return nil, fmt.Errorf("proxy dialer oluÅŸturulamadÄ±: %w", err)
	}

	transport := &http.Transport{
		Dial: dialer.Dial,
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second, // 10 saniye zaman aÅŸÄ±mÄ±
	}

	return client, nil
}

// DuyurularÄ± iÅŸleyen ve yeni ticker'larÄ± bulan fonksiyon
func processAnnouncements(body io.Reader) {
	var response APIResponse
	if err := json.NewDecoder(body).Decode(&response); err != nil {
		log.Printf("JSON verisi iÅŸlenemedi: %v", err)
		return
	}

	newTickers := make(map[string]bool)
	var newTickersList []string // Sadece loglama iÃ§in

	for _, announcement := range response.Data.List {
		// BaÅŸlÄ±kta "ì‹ ê·œ" veya "Market Support" kelimeleri geÃ§iyorsa
		if contains(announcement.Title, "ì‹ ê·œ") || contains(announcement.Title, "Market Support") {
			matches := tickerRegex.FindStringSubmatch(announcement.Title)
			if len(matches) > 1 {
				ticker := matches[1]
				newTickers[ticker] = true
				newTickersList = append(newTickersList, ticker)
			}
		}
	}
	
	mu.Lock()
	defer mu.Unlock()

	var newlyAdded []string
	for ticker := range newTickers {
		if !cachedTickers[ticker] {
			newlyAdded = append(newlyAdded, ticker)
		}
	}

	if len(newlyAdded) > 0 {
		fmt.Printf("\nğŸ”¥ğŸ”¥ğŸ”¥ YENÄ° LÄ°STELEME TESPÄ°T EDÄ°LDÄ°: %v ğŸ”¥ğŸ”¥ğŸ”¥\n", newlyAdded)
	}

	// Cache'i gÃ¼ncelle
	cachedTickers = newTickers
	log.Printf("Mevcut ticker listesi gÃ¼ncellendi: %v", newTickersList)
}

// string iÃ§inde alt string var mÄ± kontrolÃ¼
func contains(s, substr string) bool {
    return regexp.MustCompile(substr).MatchString(s)
}


func main() {
	log.Println("Upbit Yeni Listeleme TakipÃ§isi BaÅŸlatÄ±ldÄ±...")
	log.Printf("KullanÄ±lacak Proxy SayÄ±sÄ±: %d", len(proxies))

	// Periyodik kontrol iÃ§in ticker
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for range ticker.C {
		mu.Lock()
		// SÄ±radaki proxy'yi seÃ§
		currentProxy := proxies[proxyIndex]
		proxyIndex = (proxyIndex + 1) % len(proxies)
		mu.Unlock()

		log.Printf("Kontrol ediliyor... Proxy: %s", currentProxy)

		// SeÃ§ilen proxy ile client oluÅŸtur
		client, err := createProxyClient(currentProxy)
		if err != nil {
			log.Printf("HATA: Client oluÅŸturulamadÄ±: %v", err)
			continue
		}

		// API'ye istek oluÅŸtur
		req, err := http.NewRequest("GET", apiURL, nil)
		if err != nil {
			log.Printf("HATA: Ä°stek oluÅŸturulamadÄ±: %v", err)
			continue
		}

		// EÄŸer bir ETag'imiz varsa, If-None-Match baÅŸlÄ±ÄŸÄ±nÄ± ekle
		mu.Lock()
		if cachedETag != "" {
			req.Header.Set("If-None-Match", cachedETag)
		}
		mu.Unlock()

		// Ä°steÄŸi gÃ¶nder
		resp, err := client.Do(req)
		if err != nil {
			log.Printf("HATA: API'ye istek gÃ¶nderilemedi: %v", err)
			continue
		}
		defer resp.Body.Close()

		// HTTP durum kodunu kontrol et
		switch resp.StatusCode {
		case http.StatusOK: // 200 OK - Veri deÄŸiÅŸmiÅŸ
			log.Println("DeÄŸiÅŸiklik tespit edildi! Veri iÅŸleniyor...")
			
			// Yeni ETag'i al ve cache'i gÃ¼ncelle
			newETag := resp.Header.Get("ETag")
			mu.Lock()
			cachedETag = newETag
			mu.Unlock()
			
			processAnnouncements(resp.Body)

		case http.StatusNotModified: // 304 Not Modified - Veri aynÄ±
			log.Println("Veride deÄŸiÅŸiklik yok (304 Not Modified).")

		default: // DiÄŸer durum kodlarÄ±
			log.Printf("Beklenmedik HTTP durum kodu: %d", resp.StatusCode)
		}
	}
}
